true
let x = true in x
if false then true else false
0
succ (succ (succ 0))
3
succ (pred 0)
iszero (pred (succ (succ 0)))
if iszero 3 then 0 else 1
iszero true
if 1 then true else false
if iszero 3 then 0 else false
let id = Lx.x in id 3
let id_bool = L x:Bool. x in id_bool true
let id_nat = L x:Nat. x in id_nat 5
let x = 5 in let id_nat = L x:Nat. x in id_nat x
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in sum 21 34
let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in let sumaux = lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in let sum = fix sumaux in let prodaux = lambda f. (lambda n. (lambda m. if (iszero m) then 0 else sum n (f n (pred m)))) in let prod = fix prodaux in prod 12 5


STRING
"hello, world!"
x : String = "hello, world!"
TUPLES
{1, "text", true}
(lambda x:Nat. lambda y:String. lambda z:Bool. {x, y, z}) 1 "text" true
x : {String, Nat} = {"text", 1}
x.1
x.2

LISTS
nil Nat
cons 1 (nil Nat)
letrec length : List Nat -> Nat =
  lambda l: List Nat.
    if isnil l then 0 else succ (length (tail l))
in length (cons 1 (cons 2 (nil Nat)))

letrec append : List Nat -> List Nat -> List Nat =
  lambda l1: List Nat. lambda l2: List Nat.
    if isnil l1 then l2 else cons (head l1) (append (tail l1) l2)
in append (cons 1 (cons 2 (nil Nat))) (cons 3 (nil Nat))

letrec map : (Nat -> Nat) -> List Nat -> List Nat =
  lambda f: Nat -> Nat. lambda l: List Nat.
    if isnil l then nil Nat else cons (f (head l)) (map f (tail l))
in map (lambda x:Nat. succ x) (cons 1 (cons 2 (nil Nat)))

SUBTYPING
let f = lambda t: {Nat}. t.1 in f {1, true}
let use = lambda g: ({Nat, Bool}) -> Nat. g {0, true} in let short = lambda t:{Nat}. t.1 in use short
letrec map : (Nat -> Nat) -> List Nat -> List Nat =
  lambda f: Nat -> Nat. lambda l: List Nat.
    if isnil l then nil Nat else cons (f (head l)) (map f (tail l))


VARIANTS
let v = <left = 1> as <left:Nat, right:Bool> in case v of <left = x> => x | <right = y> => if y then 1 else 0
let chooser = lambda w: <a:Nat, b:Nat>. case w of <a = x> => x | <b = y> => succ y in chooser (<b = 2> as <a:Nat, b:Nat>)
